# Multicache 对外技术说明文档

> \*版本为功能版本，对于一期、二期需求，一期版本为1.0，二期为2.0

|  版本  |  日期  |  变更人员  |  变更原因  |  变更内容  |  备注  |
| --- | --- | --- | --- | --- | --- |
|  1.0  |  20240808  |  杨翠华  |  1.  补充说明       |  1.  初始化文档       |   |
|   |   |   |   |   |   |

# 1 引言

## 1.1 编写目标

本文档旨在介绍MultiCache的相关功能、设计原理，不涉及内部实现细节。主要用于其他模块在调研存储层时可以通过本文档简单获取所需说明。

## 1.2 阅读对象

 本文档供其他模块开发同学以及项目规划、课题管理同学使用。

# 2 功能背景

HyperChain中存储方案的设计思想中主张对区块链系统的数据以不同负载需求、不同数据特征进行划分。将数据分为连续数据与非连续数据两类，即区块、收据、快照数据和状态数据。

其中，状态数据在区块同步时，需要集中进行数据读取、数据写入，即对读写均有较高需求。现有LevelDB以append-only的方式写入数据，可以很好的满足数据写入需求，但其out-of-place的更新方式使得读取性能下降，因此不能够满足HyperChain中连续数据的存储需求。

为此，HyperChain设计MultiCache，用以承担连续数据的存储。因此HyperChain中对于MultiCache的诉求为既可实现高写入性能也能具备高读取性能。

此外，HyperChain中，根据对数据验证需求的不同，状态数据的存储选项有MultiCache和VIDB两种，其中VIDB以ADS结构组织连续数据，可以直接提供数据承诺与证明。MultiCache以KV结构组织数据，自身不提供数据证明服务，而是通过联盟网络中的节点提供签名来实现。

## 关键技术

Log-Structure-Merge Tree (LSM-tree) 提出以类似写日志的方式写入数据，充分利用顺序写入实现高写入性能，以文件大小进行数据划分。

Write Ahead Log (WAL)存储引擎在接受到数据写入请求时，先将数据写入至WAL，然后再进行自身写入逻辑(缓存写入加速读取)，从而提供数据持久性保证。

## 2.4 术语说明

|  英文  |  中文  |  含义  |
| --- | --- | --- |
|  ADS  |  认证数据结构  |  以一种特殊的方式组织数据，对其中的任意数据提供存在性、正确性验证  |
|  Append-Only  |  只追加  |  以类似写日志的方式，数据的更新、存储以追加的形式写入  |
|  Out-of-Place  |  非原地更新  |  与read-modify-write相对，修改时直接写入新数据  |

# 3 设计方案

## 3.1 整体框架

### 3.1.1 整体架构图

Multicache的整体架构图如下图所示：

[请至钉钉文档查看「白板」](https://alidocs.dingtalk.com/i/nodes/gpG2NdyVX3gZPjQGiXEvLaxMWMwvDqPk?iframeQuery=anchorId%3DX02m04n8l4foyfgvjhr75e)

Multicache中主要有以下几个重要的部件构成：

*   Batch
    
*   Memtable
    
*   Log
    
*   SSTable
    
*   HashRing
    

#### Batch

在Multicache中，Batch用于在数据写入后的一个数据收集器。不存在单条数据的写和删除操作。可以理解为 Batch 是一个批次的区块数据，在这个区块数据中，存在N条交易。最后将N条交易统一由Batch进行收集。在交易不停的 Put 到Batch之后，由平台决定是否需要将 Batch 中的数据真实地写入到存储中。

#### MemTable

Multicache的一次写入操作并不是直接将数据刷新到磁盘文件，而是首先写入到内存中作为代替，MemTable就是一个在内存中进行数据组织与维护的结构。MemTable中，所有的数据按Key排序之后按序存储，等到其存储内容的容量达到阈值时，会创建一个新的 MemTable供用户进行读写操作。Memtable的底层使用了一种跳表数据结构，这种数据结构效率可以比拟二叉查找树，绝大多数操作的时间复杂度为O(log n)，同时可以对Key进行有规律的排序。Memtable之间采用双向链表进行管理。

#### Log

Multicache的写操作并不是直接写入磁盘的，而是首先写入到内存。假设写入到内存的数据还未来得及持久化，Multicache进程发生了异常，抑或是宿主机器发生了宕机，会造成用户的写入发生丢失。因此Multicache在写内存之前会首先将所有的写操作写到日志文件中，也就是log文件。当以下异常情况发生时，均可以通过日志文件进行恢复：

1.  写log期间进程异常；
    
2.  写log完成，写内存未完成；
    
3.  write动作完成（即log、内存写入都完成）后，进程异常；
    
4.  memtable持久化过程中进程异常；
    

当第一类情况发生时，数据库重启读取log时，发现异常日志数据，抛弃该条日志数据，即视作这次用户写入失败，保障了数据库的一致性；

当第二类，第三类，第四类情况发生了，均可以通过redo日志文件中记录的写入操作完成数据库的恢复。

每次日志的写操作都是一次顺序写，因此写效率高，整体写入性能较好。

此外，Multicache的**用户写操作的原子性**同样通过日志来实现。

#### SSTable

虽然Multicache采用了先写内存的方式来提高写入效率，但是内存中数据不可能无限增长，且日志中记录的写入操作过多，会导致异常发生时，恢复时间过长。因此内存中的数据达到一定容量，就需要将数据持久化到磁盘中。除了某些元数据文件，Multicache的数据主要都是通过sstable来进行存储。

虽然在内存中，所有的数据都是按序排列的，但是当多个memetable数据持久化到磁盘后，对应的不同的sstable之间是存在交集的，在读操作时，需要对所有的sstable文件进行遍历，严重影响了读取效率。因此Multicache后台会“定期“整合这些sstable文件，该过程也称为compaction。随着compaction的进行，sstable文件在逻辑上被分成若干层，由内存数据直接dump出来的文件称为level 0层文件，后期整合而成的文件为level i 层文件。

#### HashRing

采用哈希环的方式进行数据库的组织，每一个数据库映射到哈希环上的一个点。具体来说，若设定哈希环大小为32，则环上会有0-31共32个点，最开始的时候均匀分布有四个数据库，这四个数据库分别对应了0，8，16，24四个点（图中三角形）。所有数据在像数据库存储的时候，会先进行一次哈希并对32取余以映射到哈希环的点上，然后找到在环上右边的第一个数据库存储进去。如果数据映射点上恰好有一个数据库，那么就影射到该数据库。下图中，每一个key值映射到环上任意一个点后，便会进一步映射到颜色相同的数据库上。

![Picture](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/Pd6l2Y4xKNPMO7Ma/img/620a51f2-4aa6-4beb-89e8-fd678858fa27.png)

在读取时，会遍历数据库列表得到第一个大于或等于目标哈希的即最近数据库，进行数据查询。

### 3.1.2 整体流程图

#### 写流程

![Picture](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/mPdnp8ZQ0ekwnw98/img/764de104-edc0-43e2-9fce-6227aa7bf875.png)

Multicache的写入操作分为两部分：

1.  将写操作写入日志（WAL）；
    
2.  将写操作应用到内存数据库（Memtable）；
    

在前面已经阐述了这种操作可以获得极高的写入性能，以及通过先写日志的方式保障用户的写入不丢失。

> 在未开启数据同步（Sync）的条件下，在写完日志文件以后，操作系统并不是直接将这些数据真正落到磁盘中，而是暂时留在操作系统缓存中，因此当用户写入操作完成，操作系统还未来得及落盘的情况下，发生系统宕机，就会造成写丢失；但是若只是进程异常退出，则不存在该问题。

##### 写类型

目前Multicache对外提供的写入接口有：

*   Put
    
*   Delete
    

这两种写入操作，本质上对应同一种操作，Delete操作同样会被转换成为一个 Value 为 nil 的空的 Put 操作。

##### Batch结构

无论是 Put/Delete操作，亦或者是批量操作，Multicache都会为这些操作创建一个 Batch 实例作为一个数据库的操作的最小执行单元，而 Batch的组织结构如下：

[请至钉钉文档查看「白板」](https://alidocs.dingtalk.com/i/nodes/gpG2NdyVX3gZPjQGiXEvLaxMWMwvDqPk?iframeQuery=anchorId%3DX02m04oyb75qpp5qymau7m)

在batch中，每一条数据项都按照上图格式进行编码。每条数据项编码后的第一位是这条数据项的类型（更新还是删除），之后是数据项key的长度，数据项key的内容；若该数据项不是删除操作，则再加上value的长度，value的内容。

batch中会维护一个size值，用于表示其中包含的数据量的大小。该size值为所有数据项key与value长度的累加，以及每条数据项额外的8个字节。这8个字节用于存储一条数据项额外的一些信息。

#### 读流程

[请至钉钉文档查看「白板」](https://alidocs.dingtalk.com/i/nodes/gpG2NdyVX3gZPjQGiXEvLaxMWMwvDqPk?iframeQuery=anchorId%3DX02m04pqu4pezf26ugealb)

在 Multicache中，数据的读操作分为三步：

1.  优先从 Cache 中进行数据读取，若搜索到符合条件的数据项，结束查找；
    
2.  在memory db中查找指定的key，若搜索到符合条件的数据项，结束查找；
    
3.  按低层至高层的顺序在level i层的sstable文件中查找指定的key，若搜索到符合条件的数据项，结束查找，否则返回Not Found错误，表示数据库中不存在指定的数据；
    

## 3.2 模块设计

### 3.2.1 Batch

#### 3.2.1.1 概述

Batch是一个临时缓存，用于批量处理写入请求的数据。通过将多个写操作缓存起来，Batch可以有效减少存储系统中的磁盘I/O操作，从而提升写入性能。Batch通常会将多个写入操作合并成一次性操作，从而减少系统的负载。

#### 3.2.1.2 流程

1.  写入请求接收：系统接收多个写入请求。
    
2.  数据缓存：这些写入请求的数据被缓存到Batch中。
    
3.  批量写入：当Batch缓存的数据达到一定数量或触发其他条件时，所有缓存的数据会被批量写入到存储系统中。
    
4.  清空缓存：Batch中缓存的数据在写入完成后被清空，准备接收新的写入请求。
    

#### 3.2.1.3 说明

Batch处理的关键在于它能够提高写入的效率，特别是在高并发环境中。通过批量处理，减少了单次写入带来的开销，从而提升了整体系统的写入性能。此外，Batch还能在数据持久化之前对数据进行一定的整合和优化。

### 3.2.2 Memtable

#### 3.2.2.1 概述

Memtable是一个在内存中的有序数据结构，用于临时存储尚未写入磁盘的数据。通常，Memtable会与Write-Ahead Log（WAL）配合使用，以保证数据的持久性。当Memtable中的数据达到一定的阈值时，这些数据会被写入到磁盘上的SSTable（Sorted String Table）中。

#### 3.2.2.2 流程

1.  数据写入Memtable：写入请求的数据首先被写入到Memtable中，并同时记录在WAL中以确保数据不会丢失。
    
2.  数据排序：Memtable中的数据以一定的顺序进行排序（通常是按键排序）。
    
3.  Commit：当Memtable中的数据量达到阈值，或触发了其他条件（如内存限制），系统会将Memtable中的数据写入LevelDB。
    

#### 3.2.2.3 说明

Memtable的存在使得数据写入操作在内存中完成，从而大幅提升了写入速度。通过与WAL的结合，Memtable不仅能保证数据的持久性，还能有效减少磁盘I/O操作。Memtable与SSTable的交互确保了数据最终的一致性和持久化，是分布式存储系统中非常关键的组件。

### 3.2.3 Hash环

采用哈希环的方式进行数据库的组织，每一个数据库映射到哈希环上的一个点。具体来说，若设定哈希环大小为32，则环上会有0-31共32个点，最开始的时候均匀分布有四个数据库，这四个数据库分别对应了0，8，16，24四个点（图中三角形）。所有数据在像数据库存储的时候，会先进行一次哈希并对32取余以映射到哈希环的点上，然后找到在环上右边的第一个数据库存储进去。如果数据映射点上恰好有一个数据库，那么就影射到该数据库。下图中，每一个key值映射到环上任意一个点后，便会进一步映射到颜色相同的数据库上。

![Picture](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/Pd6l2Y4xKNPMO7Ma/img/620a51f2-4aa6-4beb-89e8-fd678858fa27.png)

在读取时，会遍历数据库列表得到第一个大于或等于目标哈希的即最近数据库，进行数据查询。

## 3.3 接口设计

### 3.3.1 用户接口

**Put：用于插入或更新键值对。put(key, value)**

`key`：键。

`value`：值。

返回值：操作的状态，如成功或失败。

数据写入时首先会写入至Batch中，以Batch为单位将数据先写入WAL用于保证持久化。之后会将数据写入至内存的多级缓存结构，待commit时会将内存中的数据写入至PersistDB。

**Get：根据键获取对应的值。get(key)**

`key`：要查询的键。

返回值：操作的状态，以及找到的值。

读取数据时，会先读取内存中的多级缓存结构，之后继续从PersistDB中进行查询。

**Delete：删除指定键及其对应的值。delete(key)**

`key`：要删除的键。

返回值：操作的状态，如成功或失败。

### 3.3.2 外部接口

MultiCache通过LevelDB的接口进行数据持久化，并通过用户接口可与上层服务进行交互。

### 3.3.3 内部接口

描述系统内部各组件之间的接口和交互方式，包括 `batch`、`log`、`memtable` 和 `leveldb` 之间的关系。

batch 与 memtable：

`batch` 缓存了多个写操作，待写入WAL后，统一写入 `memtable`。

memtable 与 log：

写操作首先记录到 `log` 中以保证数据持久性，之后写入 `memtable`。

memtable 与 leveldb：

当 `memtable` 满足一定条件时，数据会被刷写到 `leveldb` 中，形成持久化存储。

# 4 其他

MultiCache本身不提供对状态数据的承诺+证明。在选用MultiCache用做数据存储时，状态数据的证明由节点签名实现。

后续开发任务将更多用于对VIDB的设计，因此MultiCache暂不进行改进设计。